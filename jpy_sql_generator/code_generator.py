"""
Python code generator for creating SQLAlchemy classes from SQL templates.

Copyright (c) 2025, Jim Schilling

This module is licensed under the MIT License.
"""

from pathlib import Path
from typing import Dict, List
from jpy_sql_generator.sql_parser import SqlParser


class PythonCodeGenerator:
    """Generator for Python classes with SQLAlchemy methods."""
    
    def __init__(self):
        self.parser = SqlParser()
    
    def generate_class(self, sql_file_path: str, output_file_path: str = None) -> str:
        """
        Generate a Python class from a SQL file.
        
        Args:
            sql_file_path: Path to the SQL template file
            output_file_path: Optional path to save the generated Python file
            
        Returns:
            Generated Python code as string
        """
        # Parse the SQL file
        class_name, method_queries = self.parser.parse_file(sql_file_path)
        
        # Generate the Python code
        python_code = self._generate_python_code(class_name, method_queries)
        
        # Save to file if output path provided
        if output_file_path:
            try:
                with open(output_file_path, 'w', encoding='utf-8') as f:
                    f.write(python_code)
            except OSError as e:
                raise OSError(f"Error writing Python file {output_file_path}: {e}") from e
        
        return python_code
    
    def _generate_python_code(self, class_name: str, method_queries: Dict[str, str]) -> str:
        """
        Generate Python class code from method queries.
        
        Args:
            class_name: Name of the class to generate
            method_queries: Dictionary mapping method names to SQL queries
            
        Returns:
            Generated Python code
        """
        # Generate class header
        code_lines = [
            '"""',
            f'Auto-generated {class_name} class with SQLAlchemy methods.',
            '"""',
            '',
            '# Auto-generated by jpy-sql-generator',
            '# Do not edit this file manually - it will be overwritten',
            '',
            'from typing import Optional, List, Dict, Any',
            'from sqlalchemy import text',
            'from sqlalchemy.engine import Connection, Result',
            'from sqlalchemy.engine.row import Row',
            '',
            '',
            f'class {class_name}:',
            '    """',
            f'    {class_name} with SQLAlchemy-based database operations.',
            '    """',
            '',
            '    def __init__(self, connection: Connection):',
            '        """',
            '        Initialize with database connection.',
            '',
            '        Args:',
            '            connection: SQLAlchemy database connection',
            '        """',
            '        self.connection = connection',
            ''
        ]
        
        # Generate methods
        for method_name, sql_query in method_queries.items():
            method_info = self.parser.get_method_info(sql_query)
            method_code = self._generate_method(method_name, sql_query, method_info)
            code_lines.extend(method_code)
            code_lines.append('')  # Add blank line between methods
        
        return '\n'.join(code_lines)
    
    def _generate_method(self, method_name: str, sql_query: str, method_info: Dict) -> List[str]:
        """
        Generate a single method from SQL query and method info.
        
        Args:
            method_name: Name of the method
            sql_query: SQL query string
            method_info: Analysis information about the method
            
        Returns:
            List of code lines for the method
        """
        lines = []
        
        # Generate method signature
        params = self._generate_method_signature(method_info['parameters'])
        # Only include comma if there are parameters
        param_part = f', {params}' if params else ''
        lines.append(f'    def {method_name}(self{param_part}) -> {"List[Row]" if method_info["is_fetch"] else "Result"}:')
        
        # Generate docstring
        docstring = self._generate_method_docstring(method_name, method_info)
        lines.extend(docstring)
        
        # Generate method body
        body = self._generate_method_body(sql_query, method_info)
        lines.extend(body)
        
        return lines
    
    def _generate_method_signature(self, parameters: List[str]) -> str:
        """
        Generate method signature with parameters.
        
        Args:
            parameters: List of parameter names
            
        Returns:
            Method signature string
        """
        if not parameters:
            return ''
        
        # Convert SQL parameters to Python parameters and remove duplicates
        python_params = []
        seen_params = set()
        for param in parameters:
            # Use original parameter name (preserve underscores)
            python_param = param
            if python_param not in seen_params:
                python_params.append(f'{python_param}: Any')
                seen_params.add(python_param)
        
        return ', '.join(python_params)
    
    def _generate_method_docstring(self, method_name: str, method_info: Dict) -> List[str]:
        """
        Generate method docstring.
        
        Args:
            method_name: Name of the method
            method_info: Method analysis information
            
        Returns:
            List of docstring lines
        """
        lines = [
            '        """',
            f'        {method_info["type"].title()} operation: {method_name}.',
            f'        Statement type: {method_info["statement_type"]}',
            '',
        ]
        
        # Add parameter documentation
        if method_info['parameters']:
            lines.append('        Args:')
            for param in method_info['parameters']:
                # Use original parameter name (preserve underscores)
                python_param = param
                lines.append(f'            {python_param}: Parameter for {param}')
            lines.append('')
        
        # Add return documentation
        if method_info['is_fetch']:
            lines.append('        Returns:')
            lines.append('            List of result rows')
        else:
            lines.append('        Returns:')
            lines.append('            SQLAlchemy Result object')
        
        lines.append('        """')
        return lines
    
    def _generate_method_body(self, sql_query: str, method_info: Dict) -> List[str]:
        """
        Generate method body with SQLAlchemy execution.
        
        Args:
            sql_query: SQL query string
            method_info: Method analysis information
            
        Returns:
            List of method body lines
        """
        lines = []
        
        # Add SQL query as string first
        sql_lines = sql_query.split('\n')
        lines.append('        sql = """')
        for line in sql_lines:
            lines.append(f'        {line}')
        lines.append('        """')
        lines.append('')
        
        # Create parameter mapping
        if method_info['parameters']:
            lines.append('        # Prepare parameters')
            param_mapping = []
            param_dict = {}
            for param in method_info['parameters']:
                # Use original parameter name (preserve underscores)
                python_param = param
                param_dict[param] = python_param
            
            for sql_param, python_param in param_dict.items():
                param_mapping.append(f'            "{sql_param}": {python_param},')
            
            lines.append('        params = {')
            lines.extend(param_mapping)
            lines.append('        }')
            lines.append('')
        
        # Execute query
        lines.append('        # Execute SQL query')
        if method_info['parameters']:
            lines.append('        result = self.connection.execute(text(sql), params)')
        else:
            lines.append('        result = self.connection.execute(text(sql))')
        lines.append('')
        
        # Handle result
        if method_info['is_fetch']:
            lines.append('        # Fetch results')
            lines.append('        return result.fetchall()')
        else:
            lines.append('        # Return result for non-select operations')
            lines.append('        return result')
        
        return lines
    
    def generate_multiple_classes(self, sql_files: List[str], output_dir: str = None) -> Dict[str, str]:
        """
        Generate multiple Python classes from SQL files.
        
        Args:
            sql_files: List of SQL file paths
            output_dir: Optional directory to save generated files
            
        Returns:
            Dictionary mapping class names to generated code
        """
        generated_classes = {}
        
        for sql_file in sql_files:
            class_name, _ = self.parser.parse_file(sql_file)
            python_code = self.generate_class(sql_file)
            generated_classes[class_name] = python_code
            
            # Save to file if output directory provided
            if output_dir:
                output_path = Path(output_dir) / f"{class_name}.py"
                try:
                    with open(output_path, 'w', encoding='utf-8') as f:
                        f.write(python_code)
                except OSError as e:
                    raise OSError(f"Error writing Python file {output_path}: {e}") from e
        
        return generated_classes 